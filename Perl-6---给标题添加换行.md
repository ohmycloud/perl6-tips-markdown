简书太扯了, 不管是什么空格都替换掉了。
开门见山, 废话不多说。如果非标题行在标题行上面, 那么这俩行之间会有一段空白, 但是你肯定遇到过:

## 这个标题会和下面的非标题行贴在一块

即使我在这一行换行也于事无补,  它们被简书吃掉啦。这不能忍! 看起来很丑有没有？下面我们就来解决这个问题, 手动在这一行的上面加上一个全角的空格, 就 okay 了。

问题似乎已经解决了, 但是我不能够。必须写个程序来帮我们解决这烦人的问题。方法就是在**标题行**后面添加一个换行符和一个全角空格（测试后行不通, 还是被吃, 换成 **`<br>`** 吧）。

```perl
use v6;

for dir(test => /\. md|markdown $/) -> $file {
    my $out   = open $file ~ '.txt', :w;
    my @lines = $file.lines;

    for @lines -> $line is rw {
        if $line ~~ /^\s*$/ {
            $out.say($line);
            next;
        }

        $line ~~ s/^ ('#' ** 1..7 .*?) $/$0\n  <br>/ unless
            $line ~~ /^\s*'```'\s*(\w+)?$/ fff $line ~~ /^\s*'```'\s*$/;
        $out.say($line);

    }
    $out.close;
}
```

其中有段代码比较有意思, 就是:

```perl
 $line ~~ /^\s*'```'\s*(\w+)?$/ fff $line ~~ /^\s*'```'\s*$/;
```

这是用来匹配代码片段的。 它匹配 **```** 标识之间的东西。这能够用于提取代码片段, 假如我有一个叫做 **input.txt** 的文本文件:

```perl

# 提取代码片段
　
## Flip 和 Flop
　
这俩单词是什么鬼? 反转操作符? 看起来很牛的样子, 我`方`了, 我觉得它像开关。

## 片段1
　
'''perl6
say 'hello';
### 我是 Perl 6 代码
'''

ff 还有 ^ff、 ff^ 和 ^ff^ 三种变体。 


## 片段2
　
''' perl
# 我是 Perl 5 代码
say 'hello' ~ 'world';
'''

# 片段3
　
'''
fff 用于对付某些特殊情况。
### 这是注释
我只是在测试 ff 和 fff 的不同。显然, fff 更智能点。
'''

```

因为简书对嵌套的 *```* 这种结构处理不好, 所以我使用单引号 *'* 来代替 *`*。我需要提取每对 **```** 之间的内容, 那么:

```perl
use v6;

my @lines = "input.txt".IO.lines;
for @lines -> $line {
    say $line if $line ~~ /^\s*'```'\s*(\w+)?$/ ff $line ~~ /^\s*'```'\s*$/;
}

```

但是对于片段3, 因为开始标识符和结束标识符都是 **```**,  `ff` 提取不到, 这时需要用到 `fff` 了:

```perl
 say $line if $line ~~ /^\s*'```'\s*(\w+)?$/ fff $line ~~ /^\s*'```'\s*$/;
```

如果你连开始和结尾的 **```** 标识符也不想要, 那么使用 `^fff^`。
